{"entries":[{"timestamp":1738853715561,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"http"],[-1,"s://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"enum NeoPixelColors {\" line1=\"    //% block=red\" line2=\"    Red = 0xFF0000,\" line3=\"    //% block=orange\" line4=\"    Orange = 0xFFA500,\" line5=\"    //% block=yellow\" line6=\"    Yellow = 0xFFFF00,\" line7=\"    //% block=green\" line8=\"    Green = 0x00FF00,\" line9=\"    //% block=blue\" line10=\"    Blue = 0x0000FF,\" line11=\"    //% block=indigo\" line12=\"    Indigo = 0x4b0082,\" line13=\"    //% block=violet\" line14=\"    Violet = 0x8a2be2,\" line15=\"    //% block=purple\" line16=\"    Purple = 0xFF00FF,\" line17=\"    //% block=white\" line18=\"    White = 0xFFFFFF,\" line19=\"    //% block=black\" line20=\"    Black = 0x000000\" line21=\"}\" numlines=\"22\"></mutation><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"enum NeoPixelMode {\" line1=\"    //% block=&quot;RGB (GRB format)&quot;\" line2=\"    RGB = 1,\" line3=\"    //% block=&quot;RGB+W&quot;\" line4=\"    RGBW = 2,\" line5=\"    //% block=&quot;RGB (RGB format)&quot;\" line6=\"    RGB_RGB = 3\" line7=\"}\" numlines=\"8\"></mutation><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"namespace neopixel {\" line1=\"    /**\" line2=\"     * A NeoPixel strip\" line3=\"     */\" line4=\"    export class Strip {\" line5=\"        buf: Buffer;\" line6=\"        pin: DigitalPin;\" line7=\"        // TODO: encode as bytes instead of 32bit\" line8=\"        brightness: number;\" line9=\"        start: number; // start offset in LED strip\" line10=\"        _length: number; // number of LEDs\" line11=\"        _mode: NeoPixelMode;\" line12=\"        _matrixWidth: number; // number of leds in a matrix - if any\" line13=\"\" line14=\"        /**\" line15=\"         * Shows all LEDs to a given color (range 0-255 for r, g, b).\" line16=\"         * @param rgb RGB color of the LED\" line17=\"         */\" line18=\"        //% blockId=&quot;neopixel_set_strip_color&quot; block=&quot;%strip|show color %rgb=neopixel_colors&quot;\" line19=\"        //% strip.defl=strip\" line20=\"        //% weight=85 blockGap=8\" line21=\"        //% parts=&quot;neopixel&quot;\" line22=\"        showColor(rgb: number) {\" line23=\"            rgb = rgb &gt;&gt; 0;\" line24=\"            this.setAllRGB(rgb);\" line25=\"            this.show();\" line26=\"        }\" line27=\"\" line28=\"        /**\" line29=\"         * Shows a rainbow pattern on all LEDs.\" line30=\"         * @param startHue the start hue value for the rainbow, eg: 1\" line31=\"         * @param endHue the end hue value for the rainbow, eg: 360\" line32=\"         */\" line33=\"        //% blockId=&quot;neopixel_set_strip_rainbow&quot; block=&quot;%strip|show rainbow from %startHue|to %endHue&quot;\" line34=\"        //% strip.defl=strip\" line35=\"        //% weight=85 blockGap=8\" line36=\"        //% parts=&quot;neopixel&quot;\" line37=\"        showRainbow(startHue: number = 1, endHue: number = 360) {\" line38=\"            if (this._length &lt;= 0) return;\" line39=\"\" line40=\"            startHue = startHue &gt;&gt; 0;\" line41=\"            endHue = endHue &gt;&gt; 0;\" line42=\"            const saturation = 100;\" line43=\"            const luminance = 50;\" line44=\"            const steps = this._length;\" line45=\"            const direction = HueInterpolationDirection.Clockwise;\" line46=\"\" line47=\"            //hue\" line48=\"            const h1 = startHue;\" line49=\"            const h2 = endHue;\" line50=\"            const hDistCW = ((h2 + 360) - h1) % 360;\" line51=\"            const hStepCW = Math.idiv((hDistCW * 100), steps);\" line52=\"            const hDistCCW = ((h1 + 360) - h2) % 360;\" line53=\"            const hStepCCW = Math.idiv(-(hDistCCW * 100), steps);\" line54=\"            let hStep: number;\" line55=\"            if (direction === HueInterpolationDirection.Clockwise) {\" line56=\"                hStep = hStepCW;\" line57=\"            } else if (direction === HueInterpolationDirection.CounterClockwise) {\" line58=\"                hStep = hStepCCW;\" line59=\"            } else {\" line60=\"                hStep = hDistCW &lt; hDistCCW ? hStepCW : hStepCCW;\" line61=\"            }\" line62=\"            const h1_100 = h1 * 100; //we multiply by 100 so we keep more accurate results while doing interpolation\" line63=\"\" line64=\"            //sat\" line65=\"            const s1 = saturation;\" line66=\"            const s2 = saturation;\" line67=\"            const sDist = s2 - s1;\" line68=\"            const sStep = Math.idiv(sDist, steps);\" line69=\"            const s1_100 = s1 * 100;\" line70=\"\" line71=\"            //lum\" line72=\"            const l1 = luminance;\" line73=\"            const l2 = luminance;\" line74=\"            const lDist = l2 - l1;\" line75=\"            const lStep = Math.idiv(lDist, steps);\" line76=\"            const l1_100 = l1 * 100\" line77=\"\" line78=\"            //interpolate\" line79=\"            if (steps === 1) {\" line80=\"                this.setPixelColor(0, hsl(h1 + hStep, s1 + sStep, l1 + lStep))\" line81=\"            } else {\" line82=\"                this.setPixelColor(0, hsl(startHue, saturation, luminance));\" line83=\"                for (let i = 1; i &lt; steps - 1; i++) {\" line84=\"                    const h = Math.idiv((h1_100 + i * hStep), 100) + 360;\" line85=\"                    const s = Math.idiv((s1_100 + i * sStep), 100);\" line86=\"                    const l = Math.idiv((l1_100 + i * lStep), 100);\" line87=\"                    this.setPixelColor(i, hsl(h, s, l));\" line88=\"                }\" line89=\"                this.setPixelColor(steps - 1, hsl(endHue, saturation, luminance));\" line90=\"            }\" line91=\"            this.show();\" line92=\"        }\" line93=\"\" line94=\"        /**\" line95=\"         * Displays a vertical bar graph based on the `value` and `high` value.\" line96=\"         * If `high` is 0, the chart gets adjusted automatically.\" line97=\"         * @param value current value to plot\" line98=\"         * @param high maximum value, eg: 255\" line99=\"         */\" line100=\"        //% weight=84\" line101=\"        //% blockId=neopixel_show_bar_graph block=&quot;%strip|show bar graph of %value|up to %high&quot;\" line102=\"        //% strip.defl=strip\" line103=\"        //% icon=&quot;\\uf080&quot;\" line104=\"        //% parts=&quot;neopixel&quot;\" line105=\"        showBarGraph(value: number, high: number): void {\" line106=\"            if (high &lt;= 0) {\" line107=\"                this.clear();\" line108=\"                this.setPixelColor(0, NeoPixelColors.Yellow);\" line109=\"                this.show();\" line110=\"                return;\" line111=\"            }\" line112=\"\" line113=\"            value = Math.abs(value);\" line114=\"            const n = this._length;\" line115=\"            const n1 = n - 1;\" line116=\"            let v = Math.idiv((value * n), high);\" line117=\"            if (v == 0) {\" line118=\"                this.setPixelColor(0, 0x666600);\" line119=\"                for (let j = 1; j &lt; n; ++j)\" line120=\"                    this.setPixelColor(j, 0);\" line121=\"            } else {\" line122=\"                for (let k = 0; k &lt; n; ++k) {\" line123=\"                    if (k &lt;= v) {\" line124=\"                        const b = Math.idiv(k * 255, n1);\" line125=\"                        this.setPixelColor(k, neopixel.rgb(b, 0, 255 - b));\" line126=\"                    }\" line127=\"                    else this.setPixelColor(k, 0);\" line128=\"                }\" line129=\"            }\" line130=\"            this.show();\" line131=\"        }\" line132=\"\" line133=\"        /**\" line134=\"         * Set LED to a given color (range 0-255 for r, g, b).\" line135=\"         * You need to call ``show`` to make the changes visible.\" line136=\"         * @param pixeloffset position of the NeoPixel in the strip\" line137=\"         * @param rgb RGB color of the LED\" line138=\"         */\" line139=\"        //% blockId=&quot;neopixel_set_pixel_color&quot; block=&quot;%strip|set pixel color at %pixeloffset|to %rgb=neopixel_colors&quot;\" line140=\"        //% strip.defl=strip\" line141=\"        //% blockGap=8\" line142=\"        //% weight=80\" line143=\"        //% parts=&quot;neopixel&quot; advanced=true\" line144=\"        setPixelColor(pixeloffset: number, rgb: number): void {\" line145=\"            this.setPixelRGB(pixeloffset &gt;&gt; 0, rgb &gt;&gt; 0);\" line146=\"        }\" line147=\"\" line148=\"        /**\" line149=\"         * Sets the number of pixels in a matrix shaped strip\" line150=\"         * @param width number of pixels in a row\" line151=\"         */\" line152=\"        //% blockId=neopixel_set_matrix_width block=&quot;%strip|set matrix width %width&quot;\" line153=\"        //% strip.defl=strip\" line154=\"        //% blockGap=8\" line155=\"        //% weight=5\" line156=\"        //% parts=&quot;neopixel&quot; advanced=true\" line157=\"        setMatrixWidth(width: number) {\" line158=\"            this._matrixWidth = Math.min(this._length, width &gt;&gt; 0);\" line159=\"        }\" line160=\"\" line161=\"        /**\" line162=\"         * Set LED to a given color (range 0-255 for r, g, b) in a matrix shaped strip\" line163=\"         * You need to call ``show`` to make the changes visible.\" line164=\"         * @param x horizontal position\" line165=\"         * @param y horizontal position\" line166=\"         * @param rgb RGB color of the LED\" line167=\"         */\" line168=\"        //% blockId=&quot;neopixel_set_matrix_color&quot; block=&quot;%strip|set matrix color at x %x|y %y|to %rgb=neopixel_colors&quot;\" line169=\"        //% strip.defl=strip\" line170=\"        //% weight=4\" line171=\"        //% parts=&quot;neopixel&quot; advanced=true\" line172=\"        setMatrixColor(x: number, y: number, rgb: number) {\" line173=\"            if (this._matrixWidth &lt;= 0) return; // not a matrix, ignore\" line174=\"            x = x &gt;&gt; 0;\" line175=\"            y = y &gt;&gt; 0;\" line176=\"            rgb = rgb &gt;&gt; 0;\" line177=\"            const cols = Math.idiv(this._length, this._matrixWidth);\" line178=\"            if (x &lt; 0 || x &gt;= this._matrixWidth || y &lt; 0 || y &gt;= cols) return;\" line179=\"            let m = x + y * this._matrixWidth;\" line180=\"            this.setPixelColor(m, rgb);\" line181=\"        }\" line182=\"\" line183=\"        /**\" line184=\"         * For NeoPixels with RGB+W LEDs, set the white LED brightness. This only works for RGB+W NeoPixels.\" line185=\"         * @param pixeloffset position of the LED in the strip\" line186=\"         * @param white brightness of the white LED\" line187=\"         */\" line188=\"        //% blockId=&quot;neopixel_set_pixel_white&quot; block=&quot;%strip|set pixel white LED at %pixeloffset|to %white&quot;\" line189=\"        //% strip.defl=strip\" line190=\"        //% blockGap=8\" line191=\"        //% weight=80\" line192=\"        //% parts=&quot;neopixel&quot; advanced=true\" line193=\"        setPixelWhiteLED(pixeloffset: number, white: number): void {\" line194=\"            if (this._mode === NeoPixelMode.RGBW) {\" line195=\"                this.setPixelW(pixeloffset &gt;&gt; 0, white &gt;&gt; 0);\" line196=\"            }\" line197=\"        }\" line198=\"\" line199=\"        /**\" line200=\"         * Send all the changes to the strip.\" line201=\"         */\" line202=\"        //% blockId=&quot;neopixel_show&quot; block=&quot;%strip|show&quot; blockGap=8\" line203=\"        //% strip.defl=strip\" line204=\"        //% weight=79\" line205=\"        //% parts=&quot;neopixel&quot;\" line206=\"        show() {\" line207=\"            // only supported in beta\" line208=\"            // ws2812b.setBufferMode(this.pin, this._mode);\" line209=\"            ws2812b.sendBuffer(this.buf, this.pin);\" line210=\"        }\" line211=\"\" line212=\"        /**\" line213=\"         * Turn off all LEDs.\" line214=\"         * You need to call ``show`` to make the changes visible.\" line215=\"         */\" line216=\"        //% blockId=&quot;neopixel_clear&quot; block=&quot;%strip|clear&quot;\" line217=\"        //% strip.defl=strip\" line218=\"        //% weight=76\" line219=\"        //% parts=&quot;neopixel&quot;\" line220=\"        clear(): void {\" line221=\"            const stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\" line222=\"            this.buf.fill(0, this.start * stride, this._length * stride);\" line223=\"        }\" line224=\"\" line225=\"        /**\" line226=\"         * Gets the number of pixels declared on the strip\" line227=\"         */\" line228=\"        //% blockId=&quot;neopixel_length&quot; block=&quot;%strip|length&quot; blockGap=8\" line229=\"        //% strip.defl=strip\" line230=\"        //% weight=60 advanced=true\" line231=\"        length() {\" line232=\"            return this._length;\" line233=\"        }\" line234=\"\" line235=\"        /**\" line236=\"         * Set the brightness of the strip. This flag only applies to future operation.\" line237=\"         * @param brightness a measure of LED brightness in 0-255. eg: 255\" line238=\"         */\" line239=\"        //% blockId=&quot;neopixel_set_brightness&quot; block=&quot;%strip|set brightness %brightness&quot; blockGap=8\" line240=\"        //% strip.defl=strip\" line241=\"        //% weight=59\" line242=\"        //% parts=&quot;neopixel&quot; advanced=true\" line243=\"        setBrightness(brightness: number): void {\" line244=\"            this.brightness = brightness &amp; 0xff;\" line245=\"        }\" line246=\"\" line247=\"        /**\" line248=\"         * Apply brightness to current colors using a quadratic easing function.\" line249=\"         **/\" line250=\"        //% blockId=&quot;neopixel_each_brightness&quot; block=&quot;%strip|ease brightness&quot; blockGap=8\" line251=\"        //% strip.defl=strip\" line252=\"        //% weight=58\" line253=\"        //% parts=&quot;neopixel&quot; advanced=true\" line254=\"        easeBrightness(): void {\" line255=\"            const stride2 = this._mode === NeoPixelMode.RGBW ? 4 : 3;\" line256=\"            const br = this.brightness;\" line257=\"            const buf = this.buf;\" line258=\"            const end = this.start + this._length;\" line259=\"            const mid = Math.idiv(this._length, 2);\" line260=\"            for (let o = this.start; o &lt; end; ++o) {\" line261=\"                const p = o - this.start;\" line262=\"                const ledoffset = o * stride2;\" line263=\"                const br2 = p &gt; mid\" line264=\"                    ? Math.idiv(255 * (this._length - 1 - p) * (this._length - 1 - p), (mid * mid))\" line265=\"                    : Math.idiv(255 * p * p, (mid * mid));\" line266=\"                const r = (buf[ledoffset + 0] * br2) &gt;&gt; 8; buf[ledoffset + 0] = r;\" line267=\"                const g = (buf[ledoffset + 1] * br2) &gt;&gt; 8; buf[ledoffset + 1] = g;\" line268=\"                const c = (buf[ledoffset + 2] * br2) &gt;&gt; 8; buf[ledoffset + 2] = c;\" line269=\"                if (stride2 == 4) {\" line270=\"                    const w = (buf[ledoffset + 3] * br2) &gt;&gt; 8; buf[ledoffset + 3] = w;\" line271=\"                }\" line272=\"            }\" line273=\"        }\" line274=\"\" line275=\"        /**\" line276=\"         * Create a range of LEDs.\" line277=\"         * @param start offset in the LED strip to start the range\" line278=\"         * @param length number of LEDs in the range. eg: 4\" line279=\"         */\" line280=\"        //% weight=89\" line281=\"        //% blockId=&quot;neopixel_range&quot; block=&quot;%strip|range from %start|with %length|leds&quot;\" line282=\"        //% strip.defl=strip\" line283=\"        //% parts=&quot;neopixel&quot;\" line284=\"        //% blockSetVariable=range\" line285=\"        range(start: number, length: number): Strip {\" line286=\"            start = start &gt;&gt; 0;\" line287=\"            length = length &gt;&gt; 0;\" line288=\"            let strip = new Strip();\" line289=\"            strip.buf = this.buf;\" line290=\"            strip.pin = this.pin;\" line291=\"            strip.brightness = this.brightness;\" line292=\"            strip.start = this.start + Math.clamp(0, this._length - 1, start);\" line293=\"            strip._length = Math.clamp(0, this._length - (strip.start - this.start), length);\" line294=\"            strip._matrixWidth = 0;\" line295=\"            strip._mode = this._mode;\" line296=\"            return strip;\" line297=\"        }\" line298=\"\" line299=\"        /**\" line300=\"         * Shift LEDs forward and clear with zeros.\" line301=\"         * You need to call ``show`` to make the changes visible.\" line302=\"         * @param offset number of pixels to shift forward, eg: 1\" line303=\"         */\" line304=\"        //% blockId=&quot;neopixel_shift&quot; block=&quot;%strip|shift pixels by %offset&quot; blockGap=8\" line305=\"        //% strip.defl=strip\" line306=\"        //% weight=40\" line307=\"        //% parts=&quot;neopixel&quot;\" line308=\"        shift(offset: number = 1): void {\" line309=\"            offset = offset &gt;&gt; 0;\" line310=\"            const stride3 = this._mode === NeoPixelMode.RGBW ? 4 : 3;\" line311=\"            this.buf.shift(-offset * stride3, this.start * stride3, this._length * stride3)\" line312=\"        }\" line313=\"\" line314=\"        /**\" line315=\"         * Rotate LEDs forward.\" line316=\"         * You need to call ``show`` to make the changes visible.\" line317=\"         * @param offset number of pixels to rotate forward, eg: 1\" line318=\"         */\" line319=\"        //% blockId=&quot;neopixel_rotate&quot; block=&quot;%strip|rotate pixels by %offset&quot; blockGap=8\" line320=\"        //% strip.defl=strip\" line321=\"        //% weight=39\" line322=\"        //% parts=&quot;neopixel&quot;\" line323=\"        rotate(offset: number = 1): void {\" line324=\"            offset = offset &gt;&gt; 0;\" line325=\"            const stride4 = this._mode === NeoPixelMode.RGBW ? 4 : 3;\" line326=\"            this.buf.rotate(-offset * stride4, this.start * stride4, this._length * stride4)\" line327=\"        }\" line328=\"\" line329=\"        /**\" line330=\"         * Set the pin where the neopixel is connected, defaults to P0.\" line331=\"         */\" line332=\"        //% weight=10\" line333=\"        //% parts=&quot;neopixel&quot; advanced=true\" line334=\"        setPin(pin: DigitalPin): void {\" line335=\"            this.pin = pin;\" line336=\"            pins.digitalWritePin(this.pin, 0);\" line337=\"            // don't yield to avoid races on initialization\" line338=\"        }\" line339=\"\" line340=\"        /**\" line341=\"         * Estimates the electrical current (mA) consumed by the current light configuration.\" line342=\"         */\" line343=\"        //% weight=9 blockId=neopixel_power block=&quot;%strip|power (mA)&quot;\" line344=\"        //% strip.defl=strip\" line345=\"        //% advanced=true\" line346=\"        power(): number {\" line347=\"            const stride5 = this._mode === NeoPixelMode.RGBW ? 4 : 3;\" line348=\"            const end2 = this.start + this._length;\" line349=\"            let q = 0;\" line350=\"            for (let t = this.start; t &lt; end2; ++t) {\" line351=\"                const ledoffset2 = t * stride5;\" line352=\"                for (let u = 0; u &lt; stride5; ++u) {\" line353=\"                    q += this.buf[t + u];\" line354=\"                }\" line355=\"            }\" line356=\"            return Math.idiv(this.length() * 7, 10) /* 0.7mA per neopixel */\" line357=\"                + Math.idiv(q * 480, 10000); /* rought approximation */\" line358=\"        }\" line359=\"\" line360=\"        private setBufferRGB(offset: number, red: number, green: number, blue: number): void {\" line361=\"            if (this._mode === NeoPixelMode.RGB_RGB) {\" line362=\"                this.buf[offset + 0] = red;\" line363=\"                this.buf[offset + 1] = green;\" line364=\"            } else {\" line365=\"                this.buf[offset + 0] = green;\" line366=\"                this.buf[offset + 1] = red;\" line367=\"            }\" line368=\"            this.buf[offset + 2] = blue;\" line369=\"        }\" line370=\"\" line371=\"        private setAllRGB(rgb: number) {\" line372=\"            let red = unpackR(rgb);\" line373=\"            let green = unpackG(rgb);\" line374=\"            let blue = unpackB(rgb);\" line375=\"\" line376=\"            const br3 = this.brightness;\" line377=\"            if (br3 &lt; 255) {\" line378=\"                red = (red * br3) &gt;&gt; 8;\" line379=\"                green = (green * br3) &gt;&gt; 8;\" line380=\"                blue = (blue * br3) &gt;&gt; 8;\" line381=\"            }\" line382=\"            const end3 = this.start + this._length;\" line383=\"            const stride6 = this._mode === NeoPixelMode.RGBW ? 4 : 3;\" line384=\"            for (let a = this.start; a &lt; end3; ++a) {\" line385=\"                this.setBufferRGB(a * stride6, red, green, blue)\" line386=\"            }\" line387=\"        }\" line388=\"        private setAllW(white: number) {\" line389=\"            if (this._mode !== NeoPixelMode.RGBW)\" line390=\"                return;\" line391=\"\" line392=\"            let br4 = this.brightness;\" line393=\"            if (br4 &lt; 255) {\" line394=\"                white = (white * br4) &gt;&gt; 8;\" line395=\"            }\" line396=\"            let buf2 = this.buf;\" line397=\"            let end4 = this.start + this._length;\" line398=\"            for (let d = this.start; d &lt; end4; ++d) {\" line399=\"                let ledoffset3 = d * 4;\" line400=\"                buf2[ledoffset3 + 3] = white;\" line401=\"            }\" line402=\"        }\" line403=\"        private setPixelRGB(pixeloffset: number, rgb: number): void {\" line404=\"            if (pixeloffset &lt; 0\" line405=\"                || pixeloffset &gt;= this._length)\" line406=\"                return;\" line407=\"\" line408=\"            let stride7 = this._mode === NeoPixelMode.RGBW ? 4 : 3;\" line409=\"            pixeloffset = (pixeloffset + this.start) * stride7;\" line410=\"\" line411=\"            let red2 = unpackR(rgb);\" line412=\"            let green2 = unpackG(rgb);\" line413=\"            let blue2 = unpackB(rgb);\" line414=\"\" line415=\"            let br5 = this.brightness;\" line416=\"            if (br5 &lt; 255) {\" line417=\"                red2 = (red2 * br5) &gt;&gt; 8;\" line418=\"                green2 = (green2 * br5) &gt;&gt; 8;\" line419=\"                blue2 = (blue2 * br5) &gt;&gt; 8;\" line420=\"            }\" line421=\"            this.setBufferRGB(pixeloffset, red2, green2, blue2)\" line422=\"        }\" line423=\"        private setPixelW(pixeloffset: number, white: number): void {\" line424=\"            if (this._mode !== NeoPixelMode.RGBW)\" line425=\"                return;\" line426=\"\" line427=\"            if (pixeloffset &lt; 0\" line428=\"                || pixeloffset &gt;= this._length)\" line429=\"                return;\" line430=\"\" line431=\"            pixeloffset = (pixeloffset + this.start) * 4;\" line432=\"\" line433=\"            let br6 = this.brightness;\" line434=\"            if (br6 &lt; 255) {\" line435=\"                white = (white * br6) &gt;&gt; 8;\" line436=\"            }\" line437=\"            let buf3 = this.buf;\" line438=\"            buf3[pixeloffset + 3] = white;\" line439=\"        }\" line440=\"    }\" line441=\"\" line442=\"    /**\" line443=\"     * Create a new NeoPixel driver for `numleds` LEDs.\" line444=\"     * @param pin the pin where the neopixel is connected.\" line445=\"     * @param numleds number of leds in the strip, eg: 24,30,60,64\" line446=\"     */\" line447=\"    //% blockId=&quot;neopixel_create&quot; block=&quot;NeoPixel at pin %pin|with %numleds|leds as %mode&quot;\" line448=\"    //% weight=90 blockGap=8\" line449=\"    //% parts=&quot;neopixel&quot;\" line450=\"    //% trackArgs=0,2\" line451=\"    //% blockSetVariable=strip\" line452=\"    export function create(pin: DigitalPin, numleds: number, mode: NeoPixelMode): Strip {\" line453=\"        let strip2 = new Strip();\" line454=\"        let stride8 = mode === NeoPixelMode.RGBW ? 4 : 3;\" line455=\"        strip2.buf = pins.createBuffer(numleds * stride8);\" line456=\"        strip2.start = 0;\" line457=\"        strip2._length = numleds;\" line458=\"        strip2._mode = mode || NeoPixelMode.RGB;\" line459=\"        strip2._matrixWidth = 0;\" line460=\"        strip2.setBrightness(128)\" line461=\"        strip2.setPin(pin)\" line462=\"        return strip2;\" line463=\"    }\" line464=\"\" line465=\"    /**\" line466=\"     * Converts red, green, blue channels into a RGB color\" line467=\"     * @param red value of the red channel between 0 and 255. eg: 255\" line468=\"     * @param green value of the green channel between 0 and 255. eg: 255\" line469=\"     * @param blue value of the blue channel between 0 and 255. eg: 255\" line470=\"     */\" line471=\"    //% weight=1\" line472=\"    //% blockId=&quot;neopixel_rgb&quot; block=&quot;red %red|green %green|blue %blue&quot;\" line473=\"    //% advanced=true\" line474=\"    export function rgb(red: number, green: number, blue: number): number {\" line475=\"        return packRGB(red, green, blue);\" line476=\"    }\" line477=\"\" line478=\"    /**\" line479=\"     * Gets the RGB value of a known color\" line480=\"    */\" line481=\"    //% weight=2 blockGap=8\" line482=\"    //% blockId=&quot;neopixel_colors&quot; block=&quot;%color&quot;\" line483=\"    //% advanced=true\" line484=\"    export function colors(color: NeoPixelColors): number {\" line485=\"        return color;\" line486=\"    }\" line487=\"\" line488=\"    function packRGB(a: number, b: number, c: number): number {\" line489=\"        return ((a &amp; 0xFF) &lt;&lt; 16) | ((b &amp; 0xFF) &lt;&lt; 8) | (c &amp; 0xFF);\" line490=\"    }\" line491=\"    function unpackR(rgb: number): number {\" line492=\"        let e = (rgb &gt;&gt; 16) &amp; 0xFF;\" line493=\"        return e;\" line494=\"    }\" line495=\"    function unpackG(rgb: number): number {\" line496=\"        let f = (rgb &gt;&gt; 8) &amp; 0xFF;\" line497=\"        return f;\" line498=\"    }\" line499=\"    function unpackB(rgb: number): number {\" line500=\"        let b2 = (rgb) &amp; 0xFF;\" line501=\"        return b2;\" line502=\"    }\" line503=\"\" line504=\"    /**\" line505=\"     * Converts a hue saturation luminosity value into a RGB color\" line506=\"     * @param h hue from 0 to 360\" line507=\"     * @param s saturation from 0 to 99\" line508=\"     * @param l luminosity from 0 to 99\" line509=\"     */\" line510=\"    //% blockId=neopixelHSL block=&quot;hue %h|saturation %s|luminosity %l&quot;\" line511=\"    export function hsl(h: number, s: number, l: number): number {\" line512=\"        h = Math.round(h);\" line513=\"        s = Math.round(s);\" line514=\"        l = Math.round(l);\" line515=\"\" line516=\"        h = h % 360;\" line517=\"        s = Math.clamp(0, 99, s);\" line518=\"        l = Math.clamp(0, 99, l);\" line519=\"        let c2 = Math.idiv((((100 - Math.abs(2 * l - 100)) * s) &lt;&lt; 8), 10000); //chroma, [0,255]\" line520=\"        let h12 = Math.idiv(h, 60);//[0,6]\" line521=\"        let h22 = Math.idiv((h - h12 * 60) * 256, 60);//[0,255]\" line522=\"        let temp = Math.abs((((h12 % 2) &lt;&lt; 8) + h22) - 256);\" line523=\"        let x = (c2 * (256 - (temp))) &gt;&gt; 8;//[0,255], second largest component of this color\" line524=\"        let r$: number;\" line525=\"        let g$: number;\" line526=\"        let b$: number;\" line527=\"        if (h12 == 0) {\" line528=\"            r$ = c2; g$ = x; b$ = 0;\" line529=\"        } else if (h12 == 1) {\" line530=\"            r$ = x; g$ = c2; b$ = 0;\" line531=\"        } else if (h12 == 2) {\" line532=\"            r$ = 0; g$ = c2; b$ = x;\" line533=\"        } else if (h12 == 3) {\" line534=\"            r$ = 0; g$ = x; b$ = c2;\" line535=\"        } else if (h12 == 4) {\" line536=\"            r$ = x; g$ = 0; b$ = c2;\" line537=\"        } else if (h12 == 5) {\" line538=\"            r$ = c2; g$ = 0; b$ = x;\" line539=\"        }\" line540=\"        let m2 = Math.idiv((Math.idiv((l * 2 &lt;&lt; 8), 100) - c2), 2);\" line541=\"        let r2 = r$ + m2;\" line542=\"        let g2 = g$ + m2;\" line543=\"        let b3 = b$ + m2;\" line544=\"        return packRGB(r2, g2, b3);\" line545=\"    }\" line546=\"\" line547=\"    export enum HueInterpolationDirection {\" line548=\"        Clockwise,\" line549=\"        CounterClockwise,\" line550=\"        Shortest\" line551=\"    }\" line552=\"}\" numlines=\"553\"></mutation></block></next></block></next></block></statement></block>"],[1,"://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n"],[0,"</xm"]],"start1":12,"start2":12,"length1":28109,"length2":113}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"/**\n * Well known colors for a NeoPixel strip\n */\nenum NeoPixelColors {\n    //% block=red\n    Red = 0xFF0000,\n    //% block=orange\n    Orange = 0xFFA500,\n    //% block=yellow\n    Yellow = 0xFFFF00,\n    //% block=green\n    Green = 0x00FF00,\n    //% block=blue\n    Blue = 0x0000FF,\n    //% block=indigo\n    Indigo = 0x4b0082,\n    //% block=violet\n    Violet = 0x8a2be2,\n    //% block=purple\n    Purple = 0xFF00FF,\n    //% block=white\n    White = 0xFFFFFF,\n    //% block=black\n    Black = 0x000000\n}\n\n/**\n * Different modes for RGB or RGB+W NeoPixel strips\n */\nenum NeoPixelMode {\n    //% block=\"RGB (GRB format)\"\n    RGB = 1,\n    //% block=\"RGB+W\"\n    RGBW = 2,\n    //% block=\"RGB (RGB format)\"\n    RGB_RGB = 3\n}\n\n/**\n * Functions to operate NeoPixel strips.\n */\n//% weight=5 color=#2699BF icon=\"\\uf110\"\nnamespace neopixel {\n    /**\n     * A NeoPixel strip\n     */\n    export class Strip {\n        buf: Buffer;\n        pin: DigitalPin;\n        // TODO: encode as bytes instead of 32bit\n        brightness: number;\n        start: number; // start offset in LED strip\n        _length: number; // number of LEDs\n        _mode: NeoPixelMode;\n        _matrixWidth: number; // number of leds in a matrix - if any\n\n        /**\n         * Shows all LEDs to a given color (range 0-255 for r, g, b).\n         * @param rgb RGB color of the LED\n         */\n        //% blockId=\"neopixel_set_strip_color\" block=\"%strip|show color %rgb=neopixel_colors\"\n        //% strip.defl=strip\n        //% weight=85 blockGap=8\n        //% parts=\"neopixel\"\n        showColor(rgb: number) {\n            rgb = rgb >> 0;\n            this.setAllRGB(rgb);\n            this.show();\n        }\n\n        /**\n         * Shows a rainbow pattern on all LEDs.\n         * @param startHue the start hue value for the rainbow, eg: 1\n         * @param endHue the end hue value for the rainbow, eg: 360\n         */\n        //% blockId=\"neopixel_set_strip_rainbow\" block=\"%strip|show rainbow from %startHue|to %endHue\"\n        //% strip.defl=strip\n        //% weight=85 blockGap=8\n        //% parts=\"neopixel\"\n        showRainbow(startHue: number = 1, endHue: number = 360) {\n            if (this._length <= 0) return;\n\n            startHue = startHue >> 0;\n            endHue = endHue >> 0;\n            const saturation = 100;\n            const luminance = 50;\n            const steps = this._length;\n            const direction = HueInterpolationDirection.Clockwise;\n\n            //hue\n            const h1 = startHue;\n            const h2 = endHue;\n            const hDistCW = ((h2 + 360) - h1) % 360;\n            const hStepCW = Math.idiv((hDistCW * 100), steps);\n            const hDistCCW = ((h1 + 360) - h2) % 360;\n            const hStepCCW = Math.idiv(-(hDistCCW * 100), steps);\n            let hStep: number;\n            if (direction === HueInterpolationDirection.Clockwise) {\n                hStep = hStepCW;\n            } else if (direction === HueInterpolationDirection.CounterClockwise) {\n                hStep = hStepCCW;\n            } else {\n                hStep = hDistCW < hDistCCW ? hStepCW : hStepCCW;\n            }\n            const h1_100 = h1 * 100; //we multiply by 100 so we keep more accurate results while doing interpolation\n\n            //sat\n            const s1 = saturation;\n            const s2 = saturation;\n            const sDist = s2 - s1;\n            const sStep = Math.idiv(sDist, steps);\n            const s1_100 = s1 * 100;\n\n            //lum\n            const l1 = luminance;\n            const l2 = luminance;\n            const lDist = l2 - l1;\n            const lStep = Math.idiv(lDist, steps);\n            const l1_100 = l1 * 100\n\n            //interpolate\n            if (steps === 1) {\n                this.setPixelColor(0, hsl(h1 + hStep, s1 + sStep, l1 + lStep))\n            } else {\n                this.setPixelColor(0, hsl(startHue, saturation, luminance));\n                for (let i = 1; i < steps - 1; i++) {\n                    const h = Math.idiv((h1_100 + i * hStep), 100) + 360;\n                    const s = Math.idiv((s1_100 + i * sStep), 100);\n                    const l = Math.idiv((l1_100 + i * lStep), 100);\n                    this.setPixelColor(i, hsl(h, s, l));\n                }\n                this.setPixelColor(steps - 1, hsl(endHue, saturation, luminance));\n            }\n            this.show();\n        }\n\n        /**\n         * Displays a vertical bar graph based on the `value` and `high` value.\n         * If `high` is 0, the chart gets adjusted automatically.\n         * @param value current value to plot\n         * @param high maximum value, eg: 255\n         */\n        //% weight=84\n        //% blockId=neopixel_show_bar_graph block=\"%strip|show bar graph of %value|up to %high\"\n        //% strip.defl=strip\n        //% icon=\"\\uf080\"\n        //% parts=\"neopixel\"\n        showBarGraph(value: number, high: number): void {\n            if (high <= 0) {\n                this.clear();\n                this.setPixelColor(0, NeoPixelColors.Yellow);\n                this.show();\n                return;\n            }\n\n            value = Math.abs(value);\n            const n = this._length;\n            const n1 = n - 1;\n            let v = Math.idiv((value * n), high);\n            if (v == 0) {\n                this.setPixelColor(0, 0x666600);\n                for (let i = 1; i < n; ++i)\n                    this.setPixelColor(i, 0);\n            } else {\n                for (let i = 0; i < n; ++i) {\n                    if (i <= v) {\n                        const b = Math.idiv(i * 255, n1);\n                        this.setPixelColor(i, neopixel.rgb(b, 0, 255 - b));\n                    }\n                    else this.setPixelColor(i, 0);\n                }\n            }\n            this.show();\n        }\n\n        /**\n         * Set LED to a given color (range 0-255 for r, g, b).\n         * You need to call ``show`` to make the changes visible.\n         * @param pixeloffset position of the NeoPixel in the strip\n         * @param rgb RGB color of the LED\n         */\n        //% blockId=\"neopixel_set_pixel_color\" block=\"%strip|set pixel color at %pixeloffset|to %rgb=neopixel_colors\"\n        //% strip.defl=strip\n        //% blockGap=8\n        //% weight=80\n        //% parts=\"neopixel\" advanced=true\n        setPixelColor(pixeloffset: number, rgb: number): void {\n            this.setPixelRGB(pixeloffset >> 0, rgb >> 0);\n        }\n\n        /**\n         * Sets the number of pixels in a matrix shaped strip\n         * @param width number of pixels in a row\n         */\n        //% blockId=neopixel_set_matrix_width block=\"%strip|set matrix width %width\"\n        //% strip.defl=strip\n        //% blockGap=8\n        //% weight=5\n        //% parts=\"neopixel\" advanced=true\n        setMatrixWidth(width: number) {\n            this._matrixWidth = Math.min(this._length, width >> 0);\n        }\n\n        /**\n         * Set LED to a given color (range 0-255 for r, g, b) in a matrix shaped strip\n         * You need to call ``show`` to make the changes visible.\n         * @param x horizontal position\n         * @param y horizontal position\n         * @param rgb RGB color of the LED\n         */\n        //% blockId=\"neopixel_set_matrix_color\" block=\"%strip|set matrix color at x %x|y %y|to %rgb=neopixel_colors\"\n        //% strip.defl=strip\n        //% weight=4\n        //% parts=\"neopixel\" advanced=true\n        setMatrixColor(x: number, y: number, rgb: number) {\n            if (this._matrixWidth <= 0) return; // not a matrix, ignore\n            x = x >> 0;\n            y = y >> 0;\n            rgb = rgb >> 0;\n            const cols = Math.idiv(this._length, this._matrixWidth);\n            if (x < 0 || x >= this._matrixWidth || y < 0 || y >= cols) return;\n            let i = x + y * this._matrixWidth;\n            this.setPixelColor(i, rgb);\n        }\n\n        /**\n         * For NeoPixels with RGB+W LEDs, set the white LED brightness. This only works for RGB+W NeoPixels.\n         * @param pixeloffset position of the LED in the strip\n         * @param white brightness of the white LED\n         */\n        //% blockId=\"neopixel_set_pixel_white\" block=\"%strip|set pixel white LED at %pixeloffset|to %white\"\n        //% strip.defl=strip\n        //% blockGap=8\n        //% weight=80\n        //% parts=\"neopixel\" advanced=true\n        setPixelWhiteLED(pixeloffset: number, white: number): void {\n            if (this._mode === NeoPixelMode.RGBW) {\n                this.setPixelW(pixeloffset >> 0, white >> 0);\n            }\n        }\n\n        /**\n         * Send all the changes to the strip.\n         */\n        //% blockId=\"neopixel_show\" block=\"%strip|show\" blockGap=8\n        //% strip.defl=strip\n        //% weight=79\n        //% parts=\"neopixel\"\n        show() {\n            // only supported in beta\n            // ws2812b.setBufferMode(this.pin, this._mode);\n            ws2812b.sendBuffer(this.buf, this.pin);\n        }\n\n        /**\n         * Turn off all LEDs.\n         * You need to call ``show`` to make the changes visible.\n         */\n        //% blockId=\"neopixel_clear\" block=\"%strip|clear\"\n        //% strip.defl=strip\n        //% weight=76\n        //% parts=\"neopixel\"\n        clear(): void {\n            const stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            this.buf.fill(0, this.start * stride, this._length * stride);\n        }\n\n        /**\n         * Gets the number of pixels declared on the strip\n         */\n        //% blockId=\"neopixel_length\" block=\"%strip|length\" blockGap=8\n        //% strip.defl=strip\n        //% weight=60 advanced=true\n        length() {\n            return this._length;\n        }\n\n        /**\n         * Set the brightness of the strip. This flag only applies to future operation.\n         * @param brightness a measure of LED brightness in 0-255. eg: 255\n         */\n        //% blockId=\"neopixel_set_brightness\" block=\"%strip|set brightness %brightness\" blockGap=8\n        //% strip.defl=strip\n        //% weight=59\n        //% parts=\"neopixel\" advanced=true\n        setBrightness(brightness: number): void {\n            this.brightness = brightness & 0xff;\n        }\n\n        /**\n         * Apply brightness to current colors using a quadratic easing function.\n         **/\n        //% blockId=\"neopixel_each_brightness\" block=\"%strip|ease brightness\" blockGap=8\n        //% strip.defl=strip\n        //% weight=58\n        //% parts=\"neopixel\" advanced=true\n        easeBrightness(): void {\n            const stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            const br = this.brightness;\n            const buf = this.buf;\n            const end = this.start + this._length;\n            const mid = Math.idiv(this._length, 2);\n            for (let i = this.start; i < end; ++i) {\n                const k = i - this.start;\n                const ledoffset = i * stride;\n                const br = k > mid\n                    ? Math.idiv(255 * (this._length - 1 - k) * (this._length - 1 - k), (mid * mid))\n                    : Math.idiv(255 * k * k, (mid * mid));\n                const r = (buf[ledoffset + 0] * br) >> 8; buf[ledoffset + 0] = r;\n                const g = (buf[ledoffset + 1] * br) >> 8; buf[ledoffset + 1] = g;\n                const b = (buf[ledoffset + 2] * br) >> 8; buf[ledoffset + 2] = b;\n                if (stride == 4) {\n                    const w = (buf[ledoffset + 3] * br) >> 8; buf[ledoffset + 3] = w;\n                }\n            }\n        }\n\n        /**\n         * Create a range of LEDs.\n         * @param start offset in the LED strip to start the range\n         * @param length number of LEDs in the range. eg: 4\n         */\n        //% weight=89\n        //% blockId=\"neopixel_range\" block=\"%strip|range from %start|with %length|leds\"\n        //% strip.defl=strip\n        //% parts=\"neopixel\"\n        //% blockSetVariable=range\n        range(start: number, length: number): Strip {\n            start = start >> 0;\n            length = length >> 0;\n            let strip = new Strip();\n            strip.buf = this.buf;\n            strip.pin = this.pin;\n            strip.brightness = this.brightness;\n            strip.start = this.start + Math.clamp(0, this._length - 1, start);\n            strip._length = Math.clamp(0, this._length - (strip.start - this.start), length);\n            strip._matrixWidth = 0;\n            strip._mode = this._mode;\n            return strip;\n        }\n\n        /**\n         * Shift LEDs forward and clear with zeros.\n         * You need to call ``show`` to make the changes visible.\n         * @param offset number of pixels to shift forward, eg: 1\n         */\n        //% blockId=\"neopixel_shift\" block=\"%strip|shift pixels by %offset\" blockGap=8\n        //% strip.defl=strip\n        //% weight=40\n        //% parts=\"neopixel\"\n        shift(offset: number = 1): void {\n            offset = offset >> 0;\n            const stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            this.buf.shift(-offset * stride, this.start * stride, this._length * stride)\n        }\n\n        /**\n         * Rotate LEDs forward.\n         * You need to call ``show`` to make the changes visible.\n         * @param offset number of pixels to rotate forward, eg: 1\n         */\n        //% blockId=\"neopixel_rotate\" block=\"%strip|rotate pixels by %offset\" blockGap=8\n        //% strip.defl=strip\n        //% weight=39\n        //% parts=\"neopixel\"\n        rotate(offset: number = 1): void {\n            offset = offset >> 0;\n            const stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            this.buf.rotate(-offset * stride, this.start * stride, this._length * stride)\n        }\n\n        /**\n         * Set the pin where the neopixel is connected, defaults to P0.\n         */\n        //% weight=10\n        //% parts=\"neopixel\" advanced=true\n        setPin(pin: DigitalPin): void {\n            this.pin = pin;\n            pins.digitalWritePin(this.pin, 0);\n            // don't yield to avoid races on initialization\n        }\n\n        /**\n         * Estimates the electrical current (mA) consumed by the current light configuration.\n         */\n        //% weight=9 blockId=neopixel_power block=\"%strip|power (mA)\"\n        //% strip.defl=strip\n        //% advanced=true\n        power(): number {\n            const stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            const end = this.start + this._length;\n            let p = 0;\n            for (let i = this.start; i < end; ++i) {\n                const ledoffset = i * stride;\n                for (let j = 0; j < stride; ++j) {\n                    p += this.buf[i + j];\n                }\n            }\n            return Math.idiv(this.length() * 7, 10) /* 0.7mA per neopixel */\n                + Math.idiv(p * 480, 10000); /* rought approximation */\n        }\n\n        private setBufferRGB(offset: number, red: number, green: number, blue: number): void {\n            if (this._mode === NeoPixelMode.RGB_RGB) {\n                this.buf[offset + 0] = red;\n                this.buf[offset + 1] = green;\n            } else {\n                this.buf[offset + 0] = green;\n                this.buf[offset + 1] = red;\n            }\n            this.buf[offset + 2] = blue;\n        }\n\n        private setAllRGB(rgb: number) {\n            let red = unpackR(rgb);\n            let green = unpackG(rgb);\n            let blue = unpackB(rgb);\n\n            const br = this.brightness;\n            if (br < 255) {\n                red = (red * br) >> 8;\n                green = (green * br) >> 8;\n                blue = (blue * br) >> 8;\n            }\n            const end = this.start + this._length;\n            const stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            for (let i = this.start; i < end; ++i) {\n                this.setBufferRGB(i * stride, red, green, blue)\n            }\n        }\n        private setAllW(white: number) {\n            if (this._mode !== NeoPixelMode.RGBW)\n                return;\n\n            let br = this.brightness;\n            if (br < 255) {\n                white = (white * br) >> 8;\n            }\n            let buf = this.buf;\n            let end = this.start + this._length;\n            for (let i = this.start; i < end; ++i) {\n                let ledoffset = i * 4;\n                buf[ledoffset + 3] = white;\n            }\n        }\n        private setPixelRGB(pixeloffset: number, rgb: number): void {\n            if (pixeloffset < 0\n                || pixeloffset >= this._length)\n                return;\n\n            let stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            pixeloffset = (pixeloffset + this.start) * stride;\n\n            let red = unpackR(rgb);\n            let green = unpackG(rgb);\n            let blue = unpackB(rgb);\n\n            let br = this.brightness;\n            if (br < 255) {\n                red = (red * br) >> 8;\n                green = (green * br) >> 8;\n                blue = (blue * br) >> 8;\n            }\n            this.setBufferRGB(pixeloffset, red, green, blue)\n        }\n        private setPixelW(pixeloffset: number, white: number): void {\n            if (this._mode !== NeoPixelMode.RGBW)\n                return;\n\n            if (pixeloffset < 0\n                || pixeloffset >= this._length)\n                return;\n\n            pixeloffset = (pixeloffset + this.start) * 4;\n\n            let br = this.brightness;\n            if (br < 255) {\n                white = (white * br) >> 8;\n            }\n            let buf = this.buf;\n            buf[pixeloffset + 3] = white;\n        }\n    }\n\n    /**\n     * Create a new NeoPixel driver for `numleds` LEDs.\n     * @param pin the pin where the neopixel is connected.\n     * @param numleds number of leds in the strip, eg: 24,30,60,64\n     */\n    //% blockId=\"neopixel_create\" block=\"NeoPixel at pin %pin|with %numleds|leds as %mode\"\n    //% weight=90 blockGap=8\n    //% parts=\"neopixel\"\n    //% trackArgs=0,2\n    //% blockSetVariable=strip\n    export function create(pin: DigitalPin, numleds: number, mode: NeoPixelMode): Strip {\n        let strip = new Strip();\n        let stride = mode === NeoPixelMode.RGBW ? 4 : 3;\n        strip.buf = pins.createBuffer(numleds * stride);\n        strip.start = 0;\n        strip._length = numleds;\n        strip._mode = mode || NeoPixelMode.RGB;\n        strip._matrixWidth = 0;\n        strip.setBrightness(128)\n        strip.setPin(pin)\n        return strip;\n    }\n\n    /**\n     * Converts red, green, blue channels into a RGB color\n     * @param red value of the red channel between 0 and 255. eg: 255\n     * @param green value of the green channel between 0 and 255. eg: 255\n     * @param blue value of the blue channel between 0 and 255. eg: 255\n     */\n    //% weight=1\n    //% blockId=\"neopixel_rgb\" block=\"red %red|green %green|blue %blue\"\n    //% advanced=true\n    export function rgb(red: number, green: number, blue: number): number {\n        return packRGB(red, green, blue);\n    }\n\n    /**\n     * Gets the RGB value of a known color\n    */\n    //% weight=2 blockGap=8\n    //% blockId=\"neopixel_colors\" block=\"%color\"\n    //% advanced=true\n    export function colors(color: NeoPixelColors): number {\n        return color;\n    }\n\n    function packRGB(a: number, b: number, c: number): number {\n        return ((a & 0xFF) << 16) | ((b & 0xFF) << 8) | (c & 0xFF);\n    }\n    function unpackR(rgb: number): number {\n        let r = (rgb >> 16) & 0xFF;\n        return r;\n    }\n    function unpackG(rgb: number): number {\n        let g = (rgb >> 8) & 0xFF;\n        return g;\n    }\n    function unpackB(rgb: number): number {\n        let b = (rgb) & 0xFF;\n        return b;\n    }\n\n    /**\n     * Converts a hue saturation luminosity value into a RGB color\n     * @param h hue from 0 to 360\n     * @param s saturation from 0 to 99\n     * @param l luminosity from 0 to 99\n     */\n    //% blockId=neopixelHSL block=\"hue %h|saturation %s|luminosity %l\"\n    export function hsl(h: number, s: number, l: number): number {\n        h = Math.round(h);\n        s = Math.round(s);\n        l = Math.round(l);\n\n        h = h % 360;\n        s = Math.clamp(0, 99, s);\n        l = Math.clamp(0, 99, l);\n        let c = Math.idiv((((100 - Math.abs(2 * l - 100)) * s) << 8), 10000); //chroma, [0,255]\n        let h1 = Math.idiv(h, 60);//[0,6]\n        let h2 = Math.idiv((h - h1 * 60) * 256, 60);//[0,255]\n        let temp = Math.abs((((h1 % 2) << 8) + h2) - 256);\n        let x = (c * (256 - (temp))) >> 8;//[0,255], second largest component of this color\n        let r$: number;\n        let g$: number;\n        let b$: number;\n        if (h1 == 0) {\n            r$ = c; g$ = x; b$ = 0;\n        } else if (h1 == 1) {\n            r$ = x; g$ = c; b$ = 0;\n        } else if (h1 == 2) {\n            r$ = 0; g$ = c; b$ = x;\n        } else if (h1 == 3) {\n            r$ = 0; g$ = x; b$ = c;\n        } else if (h1 == 4) {\n            r$ = x; g$ = 0; b$ = c;\n        } else if (h1 == 5) {\n            r$ = c; g$ = 0; b$ = x;\n        }\n        let m = Math.idiv((Math.idiv((l * 2 << 8), 100) - c), 2);\n        let r = r$ + m;\n        let g = g$ + m;\n        let b = b$ + m;\n        return packRGB(r, g, b);\n    }\n\n    export enum HueInterpolationDirection {\n        Clockwise,\n        CounterClockwise,\n        Shortest\n    }\n}"],[1,"\n"]],"start1":0,"start2":0,"length1":21129,"length2":1}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0," \"*\""],[-1,",\n        \"ws2812b\": \"github:microsoft/pxt-ws2812b#v0.1.2\""],[0,"\n   "]],"start1":147,"start2":147,"length1":66,"length2":8},{"diffs":[[0,"   \""],[-1,"preferredEditor\": \"tsprj\""],[1,"additionalFilePaths\": []"],[0,"\n}\n"]],"start1":244,"start2":244,"length1":32,"length2":31}]}]},{"timestamp":1738854063978,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"art\""],[-1," id=\"~E@jCRBik$`+[K7Rpyj!\""],[0," x=\""]],"start1":100,"start2":100,"length1":34,"length2":8},{"diffs":[[0,"ent\""],[-1," id=\"yYNzo`28sUX}%5-[P4Xf\""],[0,"><mu"]],"start1":173,"start2":173,"length1":34,"length2":8},{"diffs":[[0,"ent\""],[-1," id=\"!*N,Q+B9``xY5[rRak/a\""],[0,"><mu"]],"start1":921,"start2":921,"length1":34,"length2":8},{"diffs":[[0,"ent\""],[-1," id=\",#$vK%?VU8KE:`N|[C2t\""],[0,"><mu"]],"start1":1280,"start2":1280,"length1":34,"length2":8}]}]},{"timestamp":1738855238177,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0," ],\n"],[-1,"    \"testFiles\": [\n        \"test.ts\"\n    ],\n"],[0,"    "]],"start1":297,"start2":297,"length1":52,"length2":8}]},{"type":"added","filename":"test.ts","value":"// les tests vont ici ; cela ne sera pas compil si ce paquet est utilis en tant qu'extension.\n"}]}],"snapshots":[{"timestamp":1738853715560,"editorVersion":"7.0.57","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"pxt-neopixel-sparkoh\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}}],"shares":[],"lastSaveTime":1738855238192}